---
layout:     post
title:      为什么 go 语言适合开发网游服务器端
subtitle:   
date:       2012-09-11
author:     spin6lock
header-img: img/post-bg-mma-2.jpg
catalog: true
tags:
    - [gevent, golang, 网游开发]
---

前段时间在golang-China读到这个贴：[有木人用(或打算)golang做游戏服务器端?](https://groups.google.com/forum/?fromgroups=#!searchin/golang-china/%E6%B8%B8%E6%88%8F/golang-china/meRGBDEUb3M/FNHBvBId7lUJ%20) 个人觉得golang十分适合进行网游服务器端开发，写下这篇文章总结一下。
 
从网游的角度看：
要成功的运营一款网游，很大程度上依赖于玩家自发形成的社区。只有玩家自发形成一个稳定的生态系统，游戏才能持续下去，避免鬼城的出现。而这就需要多次大量导入用户，在同时在线用户量达到某个临界点的时候，才有可能完成。因此，多人同时在线十分有必要。
 
再来看网游的常见玩法，除了排行榜这类统计和数据汇总的功能外，基本没有需要大量CPU时间的应用。以前的项目里，即时战斗产生的各种伤害计算对CPU的消耗也不大。玩家要完成一次操作，需要通过客户端-服务器端-客户端这样一个来回，为了获得高响应速度，满足玩家体验，服务器端的处理也不能占用太多时间。所以，每次请求对应的CPU占用是比较小的。
 
网游的IO主要分两个方面，一个是网络IO，一个是磁盘IO。网络IO方面，可以分成美术资源的IO和游戏逻辑指令的IO，这里主要分析游戏逻辑的IO。游戏逻辑的IO跟CPU占用的情况相似，每次请求的字节数很小，但由于多人同时在线，因此并发数相当高。另外，地图信息的广播也会带来比较频繁的网络通信。磁盘IO方面，主要是游戏数据的保存。采用不同的数据库，会有比较大的区别。以前的项目里，就经历了从MySQL转向MongoDB这种内存数据库的过程，磁盘IO不再是瓶颈。总体来说，还是用内存做一级缓冲，避免大量小数据块读写的方案。

针对网游的这些特点，golang的语言特性十分适合开发游戏服务器端。

首先，go语言提供goroutine机制作为原生的并发机制。每个goroutine所需的内存很少，实际应用中可以启动大量的goroutine对并发连接进行响应。goroutine与gevent中的greenlet很相像，遇到IO阻塞的时候，调度器就会自动切换到另一个goroutine执行，保证CPU不会因为IO而发生等待。而goroutine与gevent相比，没有了python底层的GIL限制，就不需要利用多进程来榨取多核机器的性能了。通过设置最大线程数，可以控制go所启动的线程，每个线程执行一个goroutine，让CPU满负载运行。
 
同时，go语言为goroutine提供了独到的通信机制——channel。channel发生读写的时候，也会挂起当前操作channel的goroutine，是一种同步阻塞通信。这样既达到了通信的目的，又实现同步，用CSP模型的观点看，并发模型就是通过一组进程和进程间的事件触发解决任务的。虽然说，主流的编程语言之间，只要是图灵完备的，他们就都能实现相同的功能。但go语言提供的这种协程间通信机制，十分优雅地揭示了协程通信的本质，避免了以往锁的显式使用带给程序员的心理负担，确是一大优势。进行网游开发的程序员，可以将游戏逻辑按照单线程阻塞式的写，不需要额外考虑线程调度的问题，以及线程间数据依赖的问题。因为，线程间的channel通信，已经表达了线程间的数据依赖关系了，而go的调度器会给予妥善的处理。
 
另外，go语言提供的gc机制，以及对指针的保护式使用，可以大大减轻程序员的开发压力，提高开发效率。
 
展望未来，我期待go语言社区能够提供更多的goroutine间的隔离机制。个人十分推崇erlang社区的脆崩哲学，推动应用发生预期外行为时，尽早崩溃，再fork出新进程处理新的请求。对于协程机制，需要由程序员保证执行的函数不会发生死循环，导致线程卡死。如果能够定制goroutine所执行函数的最大CPU执行时间，及所能使用的最大内存空间，对于提升系统的鲁棒性，大有裨益。

